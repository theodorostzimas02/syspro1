Θεόδωρος Τζίμας - 1115202000190 - sdi2000190 

Ο κώδικας γίνεται compile με την εντολή make all, τα αρχεία διαγράφονται με την εντολή make clean και γίνεται seperate compilation.  

Αρχικά στο types.h ορίζονται τα διάφορα Structs που θα χρησιμοποιηθούν κυρίως από τον jobExecutorServer. Συγκεκριμένα ορίζονται: 
Τα structs για το Process. Κάθε process εμπεριέχει jobID, job (την ακριβής εντολή), queue position καθώς και το PID. Έπειτα ορίζουμε το QueueNode που εμπεριέχει ένα Process καθώς και pointers για τον αμέσως επόμενο και τον αμέσως προηγούμενο Node. Τελος, ορίζουμε την ουρά Queue που εμπεριέχει Head και tail node που δείχνουν στην αρχή και στο τέλος της ουράς αντίστοιχα, JobNum με τον αριθμό jobs μια δεδομένη χρονική στιγμή σε μία ουρά καθώς και allJobs με τον αριθμό όλων των jobs που έχουν περάσει από την ουρά. Ορίζονται επίσης οι συναρτήσεις που η λειτουργία τους είναι γραμμένη στο queue.c 

Στο queue.c έχουμε αρχικά την enqueue, που δέχεται ένα process καθώς και μία ουρά. Έπειετα εισάγει στο τέλος της ουράς ενα καινούριο node με το process και αυξάνει τον αριθμό του JobNum και allJobs. Η printQueue δεν χρησιμοποιείται αλλά γράφτηκε σε περίπτωση που χρειαστεί και απλα εκτυπώνει κάθε Node σε μία ουρά. Η dequeue αφαιρεί το πρώτο node με εργασία στο οποίο δείχνει το head αλλά επίσης αλλάζει σε όλα τα επόμενα nodes το queuePosition προκείμενου να αλήθευει την δεδομένη στιγμή. Η search χρησιμοποιείται για προσπέλαση και εύρεση ενός process με βάση το αποθηκευμένο jobID του ενώ η searchByPID κάνει το ίδιο αλλά με βάση ένα PID. Η deleteNode χρησιμοποιείται για την διαγραφή ενός συγκεκριμένου process με βάση το jobID. Η freeQueue είναι υπεύθυνη για την αποδέσμευση της μνήμης κάθε ουράς.  

Στο jobCommander.c εμπεριέχεται ο πηγαίος κώδικας για τον jobCommander. Ορίζουμε fifo και clientFifo ως global variables ώστε να ανοιχθούν σε έναν fd στην συνέχεια. Η main μας δέχεται τα κατάλληλα ορίσματα. Ορίζουμε επίσης job, N (ως 1), jobID και pollState ώστε να αποθήκευσουμε τα κατάλληλα arguments ανάλογα με το mode στο οποίο εισερχόμαστε. Επίσης εδώ ορίζουμε ένα sigaction struct καθώς και μια συνάρτηση handleUSR1 που δεν έχει καποιο συγκεκριμένο ρόλο. Ορίζεται μόνο ώστε να λειτουργεί το σήμα ως μέθοδος συνέχειας του προγραμματος παρακάτω όταν και καλούμε την δημιουργία ενός jobExecutorServer και περιμένουμε πρώτα να δημιουργηθεί το κατάλληλο txt που εμπεριέχει το PID του. Το συγκεκριμένο κομμάτι έχει παρθεί απο διαφάνειες του κυρίου Δελή καθώς και απο προηγούμενες μου εργασίες στο μάθημα των Λειτουργικών Συστημάτων όπου επίσης γινόταν χρήση σημάτων. Έπειτα γίνεται το κατάλληλο error handling σε περίπτωση που ο χρήστης δώσει λάθος/μη αποδεχτά commands. Ανάλογα με την εντολή, αλλάζει το mode προκειμένου να χρησιμοποιηθεί μετά από μια switch. Για το issueJob φτιάχνουμε ενα string με οτιδήποτε μετά το δεύτερο argument. Για το setConcurrency αλλάζουμε το mode και το N που θα περαστεί (παραμένει 1 σε περίπτωση που δεν το αλλάξουμε).  Για την stop στο jobID αποθηκεύεται το δευτερο argument. Για την poll αποθηκεύουμε στο pollState εάν είναι running ή queued. Για την exit απλά αλλάζουμε το mode. Ορίζουμε μια bool εάν το txt υπάρχει. Το ανοίγουμε για να ελέγξουμε και αν υπάρχει τότε είναι true. Αν δεν υπάρχει τότε κάνουμε fork και εκτελούμε για πρώτη φορά τον jobExecutorServer και με pause περιμένουμε ενα usr1 όπως αναφέρθηκε και παραπάνω προκειμένου να συνεχίσει η λειτουργία του προγράμματος. Εφόσον δημιουργηθεί, το ανοίγουμε και διαβάζουμε το PID του σε έναν buffer και τον μετατρέπουμε με την atoi. Έπειτα δημιουργείται η clientFifo προκειμένου να στέλνει ο server στον commander στοιχεία μεσω named pipe.  Στέλνουμε SIGUSR1 στον server προκειμένου να ξέρει ότι θα σταλθεί κάτι μεσω του άλλου pipe, του fifo. Ανοίγουμε το fifo και στην συνέχεια χειριζόμαστε τα διάφορα modes μέσω της switch. Το πρώτο mode γράφει στο pipe την εντολή του issueJob καθώς και ανοίγει το clientFIfo που περιμένει ανάλογα από τον server το αποτέλεσμα και το εκτυπώνει. Το δεύτερο mode γράφει στο pipe την εντολή του setConcurrency. Το τρίτο mode γράφει την εντολή του stop αι ανοίγει το clientFifo περιμένοντας απάντηση την οποία εκτυπώνει. Παρομοίως και τα modes 4 και 5. Στο τέλος κλείνουμε το fifo και διαγράφουμε την clientFifo.  

Στο jobExecutorServer.c βρίσκεται ο πηγαίος του server. Ορίζουμε activeProcesses, και δυο queues ως global variables. Συγκεκριμένα το ProcessQueue είναι αυτό που ζήταγε η εκφώνηση προκειμένου να αποθηκεύονται οι διεργασίες πριν την εκτέλεση. Ωστόσο έφτιαξα άλλο ένα queue με όνομα RunningProcesses καθώς ήθελα να διαχειρίζομαι τις διεργασίες που τρέχουν και να μπορώ να αποθηκεύω το pid τους ώστε να σκοτωθούν εάν αυτό χρειαστεί. Στην main ορίζουμε πάλι structs sigaction για SigChild και SigUsr1. Θα επανέλθω παρακάτω στους handlers αυτών των σημάτων καθώς εκεί βρίσκεται η πλειοψηφία του κώδικα. Στην συνέχεια δημιουργούμε το txt με το PID ωστε να το χρησιμοποιήσει ο commander και δημιουργούμε και το fifo για να δέχεται δεδομένα προς διάβασμα. Έπειτα στέλνεται το SIGUSR1 για να ξεκολλήσει ο commander από το pause. Στο main loop εάν είναι null το head της processQueue και τα activeProcesses δεν αντιστοιχούν στο concurrency που έχει τεθεί, με dequeue παίρνουμε ενα process για execution. Μετά υπάρχει pause μεχρι να σταλθεί USR1 σήμα από το commander που σημαίνει οτι ο server περιμένει νέα εντολη. Η processExecute δέχεται μια διεργασία και κάνει fork ενα νεο παιδί. Έπειτα χωρίζει το string σε arguments ώστε το arg[0] να αντιστοιχεί στην εντολή προς εκτέλεση και τα υπόλοιπα να είναι τα arguments της εντολής. Εάν η εντολή δεν είναι εκτελέσιμη σημαίνει ότι βρίσκεται σε άλλο path οπότε αφαιρούμε το prefix ./ .  Εδω πρέπει να τονίσω ότι λογω προβλημάτων ίσως να χω αλλάξει τα prefixes σε μερικά απο τα testing αρχεία καθώς δεν υπήρχαν στο path μου. ΕΦόσον γίνει fork, περνάμε στο process το pid του και το βάζουμε μέσα στην RunningQueue καθώς και αυξάνουμε τα activeProcesses. Στην handleUSR1 γίνεται η βασική δουλειά του server. Όταν ο commander στείλει το σήμα τότε ο server το δέχεται και ξέρει οτι πρέπει να λάβει κάτι από το pipe και να το εκτελέσει. Ανοίγει οπότε το pipe, και διαβάζει. Εάν λάβει exit, τότε κάνει free τις ουρές, διαγράφει το pipe και το txt, κλείνει τους descriptors και κάνει exit. Εάν λάβει issueJob τότε καλέι την handleIssueJob. Η συγκεκριμένη συνάρτηση κάνει malloc μια διεργασία, ορίζει το job_ID της και το queuePosition την δεδομένη στιγμή, αποθηκεύει την εντολή προς εκτέλεση και εκχωρεί στην ProcessQueue την διεργασία ενώ επίσης τα περνάει όλα αυτά σε μία τριπλέτα. Η τριπλέτα αυτή θα περαστεί μέσω του clientFifo πίσω στον commander. Εάν λάβει τώρα από το fifo setConcurrency, καλεί την handleSetConcurrency. Η συγκεκριμένη εντολή απλά αλλάζει το concurrency αλλά και αρχίζει να τρέχει ώστε να αποφασίσει και να εκτελέσει process εφόσον αλλάξει το concurrency. Εάν λάβει stop ο server, ψάχνει μέσω του jobID την διεργασία και την κάνει Kill εάν τρέχει ενώ απλά την αφαιρεί από το queue εάν είναι ακόμη προς εκτέλεση. Ενημέρωνει κατάλληλα τον commander ακόμη και στην περίπτωση που έδωσε job που δεν υπάρχει. Εάν ο server λάβει poll, δημιουργεί ένα κατάλληλο response που γίνεται initialized. Εάν έχει λάβει running τότε γράφει όλες τις τριπλέτες του RunningQueue στο response ενώ εάν έχει λάβει queued γράφει τις αντίστοιχες τριπλέτες. Στο τέλος στέλνει μεσω της clientFifo το response. Προκείμενου να γίνεται σωστά συγχρονισμός των διεργασίων όταν τελιώσει μια, υπάρχει η handleSIGCHLD. Οταν μια διεργασία παιδί που έχουμε τρέξει τελιώσει, περιμένει πίσω το PID της. Εάν βρίσκεται στην αρχή της RunningQueue απλά το αφαιρεί. Εάν δεν είναι στο head, τότε πρώτα ψάχνει με βάση το PID που επιστράφηκε και τότε την αφαιρεί από το queue. Όπως και να χει μειώνονται τα activeProcesses ώστε να έρθουν καινούριες διεργασίες με βάση το concurrency.  

Το multijob.sh δέχεται files με εντολές προς εκτέλεση. Εάν υπάρχει το txt σημαίνει οτι ο server είναι ενεργός και άρα έχει νόημα η εκτέλεση του script. Ανάλογα με το πόσα files έχουν δωθεί, διαβάζει κάθε ένα και έπειτα διαβάζει κάθε γραμμή του file προκειμένου να την εκτελέσει μέσω του jobCommander μέσα σε μια while. 

Το allJobsStop.sh αρχικά τσεκάρει επίσης εάν υπάρχει το txt και δρα αναλόγως. Εάν υπάρχει τότε καλεί τον jobCommander με poll running και poll queued ωστε να λάβει όλες τις εντολές που τρέχουν είτε πρόκειται να τρέξουν. Εφόσον έχει γραφτεί ο server να επιστρέφει τις διεργασίες με μορφή τριπλέτας <jobID, job, queuePosition>, κάνουμε grep με κατάλληλο pattern προκειμένου να πάρουμε κάθε τριπλέτα, μετά με το cut την χωρίζουμε με βάση τα κόμματα και κρατάμε το jobID και με την tr διαγράφουμε το “<” στην αρχή. Έπειτα τρέχουμε δυο for loops, ένα για τα running jobs που βρήκαμε και ένα για τα queued. Τέλος κάνουμε exit από τον server. 
 
Γενικότερα εκτελούνται όλα τα test scripts για το κάθε test case εκτός του test case 3 (μεγαλος αριθμός arguments). Άλλο ένα πρόβλημα που λογικά οφείλεται στον τρόπο που διαβάζω από τα pipes είναι ότι υπάρχουν αρκετά garbages, ισως επειδή πολλές φορές ορίζω buffers με προκαθορισμενο μεγεθος φαντάζομαι αλλά δεν είμαι 100% σίγουρος. Ωστόσο, η εφαρμογή είναι πλήρως λειτουργική και δεν διαλύονται από τα garbages τα αποτελέσματα, απλά υπάρχουν σε κάποιες prints στο τέλος. Ωστόσο να σημειωθεί πως βρήκα λάθος κάποια απο τα test cases και εγω αλλά και συμφοιτητές μου ενώ αποτελέσματα βρίσκαμε όλοι κοινά, οπότε θα έπρεπε να είχαν αλλαχθεί τα συγκεκριμένα πριν την λήξη της εργασίας.  